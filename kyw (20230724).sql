-- 한글은 한 글자 당 3바이트를 차지, ex)10글자는 30바이트 할당이 필요

-- DML(Data Manipulation Language)
--    테이블에 원하는 자료들을 입력, 수정, 삭제, 조회하는 명령어

--INSERT 입력
--UPDATE 수정
--DELETE 삭제
--SELECT 선택

--INSERT 표현식
--1. INSERT INTO 테이블명
--(컬럼명1, 컬럼명2, ,,,)
--VALUES (컬럼명들에 넣을 밸류 값들);
--
--2. INSERT INTO 테이블명
--VALUES (전체 컬럼명들에 넣을 밸류 값들);
DESC STUDENT;

INSERT INTO STUDENT
(NO, NAME)
VALUES(1, '특이점');

INSERT INTO STUDENT
(NO, SCORENUM)
VALUES(1, 123);

INSERT INTO STUDENT
VALUES(999, '특이점A', 312.09);

SELECT *
FROM STUDENT;

--가. ALTER TABLE (테이블 구조에서 컬럼이나 제약조건을 추가 or 삭제)
--ALTER TABLE 테이블명

--ADD COLUMN (기존 테이블에 컬럼을 추가)
--ADD 추가할 컬럼명 데이터 타입;
DESC STUDENT;

ALTER TABLE STUDENT
ADD(AGE NUMBER);
    
ALTER TABLE STUDENT
ADD(AGE2 NUMBER(10));    
    
SELECT *
FROM STUDENT;

--나. MODIFY COLUMN (기존 테이블의 컬럼을 수정)
DESC STUDENT;

ALTER TABLE 테이블명
MODIFY(컬럼명1 데이터유형, 컬럼명2 데이터유형, ,,,);

ALTER TABLE STUDENT
MODIFY(NAME VARCHAR2(30));

SELECT *
FROM STUDENT;

INSERT INTO STUDENT
VALUES(1, '특이점특이점특이점', 312.091, 20, 10);

SELECT *
FROM STUDENT;

--  @ 컬럼을 변경할 때 몇 가지 사항을 고려해서 변경해야 한다
--      - 해당 컬럼의 크기를 늘릴 수는 있지만 줄이지는 못한다
--          이는 기존의 데이터가 훼손될 수 있기 때문이다
--      - 해상 컬럼이 NULL 값만 가지고 있거나 테이블에 아무 행도 없으면 컬럼의
--          폭을 줄일 수 있다
--      - 해당 컬럼이 NULL 값만을 가지고 있으면 데이터 유형을 변경할 수도 있다
--      - 해당 컬럼의 DEFAULT 값을 바꾸면 변경 작업 이후 발생하는 행 삽입에만 영향을 미치게 된다
--      - 해당 컬럼의 NULL 값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있다
DESC STUDENT;

ALTER TABLE STUDENT
MODIFY(NAME VARCHAR2(10));

ALTER TABLE STUDENT
ADD(ALIAS_NAME VARCHAR(1));

ALTER TABLE STUDENT
MODIFY(ALIAS_NAME VARCHAR(10));

DESC STUDENT;

SELECT *
FROM STUDENT;

--다. DROP COLUMN (기존 테이블에 있는 컬럼을 삭제하는 명령)
--(표현식)
ALTER TABLE 테이블명
DROP COLUMN 삭제할 컬럼명;

DESC STUDENT;

ALTER TABLE STUDENT
DROP COLUMN AGE2;

ALTER TABLE STUDENT
DROP COLUMN ALIAS_NAME;

SELECT *
FROM STUDENT;

--  @ RENAME TABLE (테이블의 이름을 변경)
--(표현식)
RENAME 변경전 테이블명 TO 변경후 테이블명;
    
RENAME AA TO BB;
    
DESC BB;

--라. DROP TABLE (테이블을 삭제)
DROP TABLE 테이블명;

DROP TABLE PURCHASE;

CREATE TABLE PURCHASE(
    CUSTOMER_NAME VARCHAR2(20),
    PRODUCT_NAME VARCHAR2(50),
    QUANTITY NUMBER(6),
    PRICE NUMBER,
    CRE_DATE DATE
);

DESC PURCHASE;

--employee테이블에 comm이라는 컬럼을 추가하시오 숫자 4자리
ALTER TABLE PURCHASE
ADD(COMM NUMBER(4));

DESC PURCHASE;

--사원 테이블에 본인명 원하는직업 연봉 커미션을 입력하시오 (직업과 comm은 입력하지 않는다)
DESC EMPLOYEE;

INSERT INTO EMPLOYEE
VALUES('김용원', '개발자', 9999, 9999);

SELECT *
FROM EMPLOYEE;

--사원 테이블에 급여 컬럼을 삭제하시오
ALTER TABLE EMPLOYEE
DROP COLUMN SAL;

SELECT *
FROM EMPLOYEE;

--  @ 필수 입력을 위한 NOT NULL 제약조건
DROP TABLE EMP01;

CREATE TABLE EMP01(
    EMPNO NUMBER(4) NOT NULL,
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(2)
);

SELECT *
FROM EMP01;

--NOT NULL 제약조건 위반
INSERT INTO EMP01
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(NULL, NULL, '개발', 30);

--  @ 테이블명 명명규칙
--      모든 글자는 대문자가 된다 (ex) empNumber -> EMPNUMBER)
--      스네이크 표기법 (ex) EMP_NUMBER, EMP_TEST1, DEPT_TEST1)

--DEPT 테이블의 구조를 파악해서 LOC을 제외한 모든 컬럼에 NOT NULL을 적용하시오
--NOT NULL 적용 후, 입력문을 통해 NOT NULL 메시지가 뜨는 경우와
--입력이 잘 되는 경우 2가지를 증명하시오
--제약조건을 자신이 만든 테이블에 적용되었는지 확인하시오
DROP TABLE DEPT_TEST1;

DESC DEPT;

DROP TABLE DEPT_TEST1;

CREATE TABLE DEPT_TEST1(
    DEPTNO NUMBER(2) NOT NULL,
    DNAME VARCHAR2(14) NOT NULL,
    LOC VARCHAR2(13)
);

INSERT INTO DEPT_TEST1
VALUE(DEPTNO, DNAME, LOC)
VALUES(77, 'STAT', 'SEOUL');

INSERT INTO DEPT_TEST1
VALUE(DEPTNO, DNAME, LOC)
VALUES(NULL, NULL, 'DAEGU');

SELECT *
FROM DEPT_TEST1;

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT_TEST1';

--  @ 유일한 값만 허용하는 UNIQUE 제약 조건
DROP TABLE EMP03;

CREATE TABLE EMP03(
    EMPNO NUMBER(4) UNIQUE,
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(2)
);

INSERT INTO EMP03
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(10, '홍길동', '개발', 30);

INSERT INTO EMP03
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(NULL, '논개', '보수', 30);

INSERT INTO EMP03
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(10, '이순신', '보수', 30);

SELECT *
FROM EMP03;

--부서테이블에서 LOC컬럼에만 UNIQUE와 NULL 값을 허용하지 않는 제약조건을 적용하고
--수행이 되는 경우와 수행이 안 되는 경우를 작성하고 제약조건이 적용되었는지 확인하시오
DROP TABLE DEPT_TEST2;

DESC DEPT;

CREATE TABLE DEPT_TEST2(
    DEPTNO NUMBER(2),
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13) UNIQUE NOT NULL
);

INSERT INTO DEPT_TEST2
VALUE(DEPTNO, DNAME, LOC)
VALUES(NULL, NULL, 'SEOUL');

INSERT INTO DEPT_TEST2
VALUE(DEPTNO, DNAME, LOC)
VALUES(NULL, NULL, 'SEOUL');

INSERT INTO DEPT_TEST2
VALUE(DEPTNO, DNAME, LOC)
VALUES(NULL, NULL, NULL);

INSERT INTO DEPT_TEST2
VALUE(DEPTNO, DNAME, LOC)
VALUES(NULL, NULL, 'BUSAN');

SELECT *
FROM DEPT_TEST2;

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT_TEST2';

--  @ 데이터 구분을 위한 PRIMARY KEY 제약조건(기본키라고도 부른다)
--      이름이 같은 사람은 존재해도 주민번호가 같은 사람은 없다
--      주민번호와 같은 유일한 정보를 만들고 싶다면, 기본키 제약조건을 사용한다
DROP TABLE EMP04;

CREATE TABLE EMP04(
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9) NOT NULL,
    DEPTNO NUMBER(2)
);

INSERT INTO EMP04
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(10, '홍길동', '개발', 30);

--unique constraint (KYW.SYS_C007119) violated
INSERT INTO EMP04       
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(10, '이순신', '개발', 30);

--cannot insert NULL into ("KYW"."EMP04"."EMPNO")
INSERT INTO EMP04
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(NULL, '임진록', '개발', 30);

INSERT INTO EMP04
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(11, '임진록', '개발', 30);

SELECT * 
FROM EMP04;

--DEPT테이블에서 DEPTNO컬럼에 기본키를 적용하시오
--나머지 컬럼들이 기본적으로 존재하고, 마지막 컬럼명을 부서의 일련번호라는 컬럼을 만들고
--제약조건은 유니크 낫 널을 적용한다
--입력이 가능한 경우와 불가능한 경우의 데이터를 입력하는데
--기본키와 유니크 낫 널의 차이를 살펴보시오
DROP TABLE DEPT_TEST3;

DESC DEPT;

CREATE TABLE DEPT_TEST3(
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13),
    D_SERIAL_NUM NUMBER UNIQUE NOT NULL
);

INSERT INTO DEPT_TEST3
VALUE(DEPTNO, DNAME, LOC, D_SERIAL_NUM)
VALUES(10, '홍길동', '개발', 1);

--unique constraint (KYW.SYS_C007124) violated
INSERT INTO DEPT_TEST3
VALUE(DEPTNO, DNAME, LOC, D_SERIAL_NUM)
VALUES(10, '홍길동', '개발', 2);

--cannot insert NULL into ("KYW"."DEPT_TEST3"."DEPTNO")
INSERT INTO DEPT_TEST3
VALUE(DEPTNO, DNAME, LOC, D_SERIAL_NUM)
VALUES(NULL, '홍길동', '개발', 2);

INSERT INTO DEPT_TEST3
VALUE(DEPTNO, DNAME, LOC, D_SERIAL_NUM)
VALUES(11, '홍길동', '개발', 2);

--unique constraint (KYW.SYS_C007125) violated
INSERT INTO DEPT_TEST3
VALUE(DEPTNO, DNAME, LOC, D_SERIAL_NUM)
VALUES(12, '홍길동', '개발', 2);

--cannot insert NULL into ("KYW"."DEPT_TEST3"."DEPTNO")
INSERT INTO DEPT_TEST3
VALUE(DEPTNO, DNAME, LOC, D_SERIAL_NUM)
VALUES(12, '홍길동', '개발', NULL);

INSERT INTO DEPT_TEST3
VALUE(DEPTNO, DNAME, LOC, D_SERIAL_NUM)
VALUES(12, '홍길동', '개발', 3);

SELECT * 
FROM DEPT_TEST3;

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT_TEST3';

--------------------------------------------------------------------------------
DROP TABLE EMP05;

CREATE TABLE EMP05(
    EMPNO NUMBER(4) CONSTRAINT EMP05_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT EMP05_ENAME_NN NOT NULL,
    JOB VARCHAR2(9) CONSTRAINT EMP05_JOB_UK UNIQUE,
    DEPTNO NUMBER(2)
);

SELECT *
FROM USER_CONSTRAINTS
WHERE CONSTRAINT_NAME LIKE 'EMP%';

--DEPT테이블 중 DEPTNO에 기본키, 부서명에 NOT NULL 제약조건명을 명시하여 적용하고, 딕셔너리에서 확인
DROP TABLE DEPT_TEST4;

DESC DEPT;

CREATE TABLE DEPT_TEST4(
    DEPTNO NUMBER(2) CONSTRAINT DEPT_TEST4_DEPTNO_PK PRIMARY KEY,
    DNAME VARCHAR2(14)CONSTRAINT DEPT_TEST4_DNAME_NN NOT NULL,
    LOC VARCHAR2(13)
);

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT_TEST4';

--------------------------------------------------------------------------------
DROP TABLE EMP06;

CREATE TABLE EMP06(
    EMPNO NUMBER(4) CONSTRAINT EMP06_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT EMP06_ENAME_NN NOT NULL,
    SAL NUMBER(7, 2) CONSTRAINT EMP06_SAL_CK CHECK(SAL >= 1000 AND SAL <= 4000),
    GENDER VARCHAR2(1) CONSTRAINT EMP06_GENDER_CK CHECK(GENDER IN('M', 'F', 'A'))
);

--check constraint (KYW.EMP06_GENDER_CK) violated
INSERT INTO EMP06
VALUE(EMPNO, ENAME, SAL, GENDER)
VALUES(1234, '행운아', 200, 'M');

INSERT INTO EMP06
VALUE(EMPNO, ENAME, SAL, GENDER)
VALUES(1234, '행운아', 1200, 'M');

INSERT INTO EMP06
VALUE(EMPNO, ENAME, SAL, GENDER)
VALUES(2345, '전학생', 3000, 'A');

SELECT *
FROM EMP06;

--------------------------------------------------------------------------------
DROP TABLE EMP07;

CREATE TABLE EMP07(
    EMPNO NUMBER(4) CONSTRAINT EMP07_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(100) DEFAULT '(본인명)' CONSTRAINT EMP07_ENAME_NN NOT NULL,
    SAL NUMBER(7, 2) DEFAULT 1000 CONSTRAINT EMP07_SAL_CK CHECK(SAL >= 1000 AND SAL <= 4000),
    GENDER VARCHAR2(1) CONSTRAINT EMP07_GENDER_CK CHECK(GENDER IN('M', 'F'))
);

INSERT INTO EMP07
VALUE(EMPNO, ENAME, SAL, GENDER)
VALUES(1234, '행운아', 1200, 'M');

INSERT INTO EMP07
VALUE(EMPNO, GENDER)
VALUES(2345, 'M');

SELECT *
FROM EMP07;

--부서 테이블에서 새로 만들어지는 부서(LOC) 중 입력하지 않으면, 무조건 서울이라는 값이 입력된다
--부서번호는 3자리의 숫자값이 입력되지 않으면 무조건 오류가 발생한다
--1오류 012오류 100성공 999성공

DROP TABLE DEPT_TEST5;

DESC DEPT;

CREATE TABLE DEPT_TEST5(
    DEPTNO NUMBER(3)CONSTRAINT DEPT_TEST5_DEPTNO_CK CHECK(DEPTNO >= 100 AND DEPTNO < 1000),
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13) DEFAULT 'SEOUL'
);

INSERT INTO DEPT_TEST5
VALUE(DEPTNO, DNAME)
VALUES(100, '행운아');

INSERT INTO DEPT_TEST5
VALUE(DEPTNO, DNAME)
VALUES(012, '행운아');

SELECT *
FROM DEPT_TEST5;

--DD (DICTIONARY DATA) 
SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT_TEST5';

--  @ 외래 키
DROP TABLE EMP08;

CREATE TABLE EMP08(
    EMPNO NUMBER(4) CONSTRAINT EMP08_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT EMP08_ENAME_NN NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(2) CONSTRAINT EMP08_DEPT08_DEPTNO_FK REFERENCES DEPT08(DEPTNO)
);

DROP TABLE EMP09;

CREATE TABLE EMP09(
    EMPNO NUMBER(4) CONSTRAINT EMP09_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT EMP09_ENAME_NN NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(2) CONSTRAINT EMP09_DEPT09_DEPTNO_FK REFERENCES DEPT09(DEPTNO)
);

DESC DEPT;

DROP TABLE DEPT08;

CREATE TABLE DEPT08(
    DEPTNO    NUMBER(2),
    DNAME     VARCHAR2(14),
    LOC       VARCHAR2(13) 
);

DROP TABLE DEPT09;

CREATE TABLE DEPT09(
    DEPTNO    NUMBER(2) PRIMARY KEY,
    DNAME     VARCHAR2(14),
    LOC       VARCHAR2(13)
);

INSERT INTO DEPT09
VALUE(DEPTNO, DNAME, LOC)
VALUES(10, '개발', 'SEOUL');

INSERT INTO DEPT09
VALUE(DEPTNO, DNAME, LOC)
VALUES(20, '총무', 'JINJU');

SELECT *
FROM DEPT09;

INSERT INTO EMP09
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(1, '전학생', '학생', 10);

INSERT INTO EMP09
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(2, '전학생2', '학생', 30);

INSERT INTO EMP09
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(2, '전학생2', '학생', 20);

INSERT INTO EMP09
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(2, '전학생2', '학생', 10);

SELECT *
FROM EMP09;

--      사원 테이블과 부서 테이블을 활용하시오
--		부서 테이블은 부모 테이블, 사원 테이블은 자식 테이블이다
--		부서에는 DEPTNO 기본키, 사원에는 EMPNO 기본키, DEPTNO 외래키로 지정한다
--		부서정보를 3개 정도 입력한다
--		사원에는 각 부서별로 1명씩 존재하고, 첫번째 부서에만 2명만 존재하도록 하시오
--      제약조건 확인
--		명명규칙, 외래키 제약조건 오류 증명하시오
DESC DEPT;

DROP TABLE DEPT_06;

CREATE TABLE DEPT_06(
    DEPTNO    NUMBER(2) PRIMARY KEY,    
    DNAME     VARCHAR2(14), 
    LOC       VARCHAR2(13) 
);

INSERT INTO DEPT_06
VALUE(DEPTNO, DNAME, LOC)
VALUES(1, 'A', 'SEOUL');

INSERT INTO DEPT_06
VALUE(DEPTNO, DNAME, LOC)
VALUES(2, 'B', 'BUSAN');

INSERT INTO DEPT_06
VALUE(DEPTNO, DNAME, LOC)
VALUES(3, 'C', 'INCHEON');

SELECT *
FROM DEPT_06;

DESC EMP;

DROP TABLE EMP_06;

CREATE TABLE EMP_06(
    EMPNO             NUMBER(4), 
    ENAME            VARCHAR2(20) PRIMARY KEY,
    JOB               VARCHAR2(9),
    DEPTNO            NUMBER(2) CONSTRAINT EMP_06_DEPT_06_FK REFERENCES DEPT_06(DEPTNO)
);

INSERT INTO EMP_06
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(1, 'AMY', '학생', 1);

INSERT INTO EMP_06
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(2, 'BELLA', '학생', 1);

INSERT INTO EMP_06
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(3, 'CHRIS', '선생', 2);

INSERT INTO EMP_06
VALUE(EMPNO, ENAME, JOB, DEPTNO)
VALUES(4, 'DANIEL', '교장', 3);

SELECT *
FROM EMP_06;

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT_06';

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP_06';

--------------------------------------------------------------------------------
DROP TABLE EMP10;

CREATE TABLE EMP10
AS
SELECT *
FROM EMP;

--제약조건 추가하기 (ALTER!!!)
ALTER TABLE EMP10
ADD CONSTRAINT EMP10_EMPNO_PK PRIMARY KEY(EMPNO);

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP10';

--DEPT 생성
CREATE TABLE DEPT10
AS
SELECT *
FROM DEPT;

SELECT *
FROM DEPT10;

--제약조건 추가하기 (ALTER!!!)
ALTER TABLE DEPT10
ADD CONSTRAINT DEPT10_DEPTNO_PK PRIMARY KEY(DEPTNO);

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT10';

--외래키 추가!!!
ALTER TABLE EMP10
ADD CONSTRAINT EMP10_DEPT10_DEPTNO_FK
FOREIGN KEY(DEPTNO) REFERENCES DEPT10(DEPTNO);
--         나의 컬럼             케이블명(부모테이블의 컬럼)

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP10';

--NOT NULL 제약조건 추가 (NOT NULL만 'MODIFY'임, 'ADD'가 아님!!!)
ALTER TABLE DEPT10
MODIFY DNAME CONSTRAINT DEPT10_DNAME_NN NOT NULL;

DESC DEPT10;

--제약조건의 조건 제거하기
SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP05';

ALTER TABLE EMP05
DROP PRIMARY KEY;

--UNIQUE, NOT NULL 등의 제약조건은 '제약조건 명'을 지움으로써 조건을 제거할 수 있음!!!
ALTER TABLE EMP05
DROP CONSTRAINT EMP05_JOB_UK;

ALTER TABLE EMP05
DROP CONSTRAINT EMP05_ENAME_NN;

--외래키 같은 '제약조건들을 강제로 무시'하고 객체들을 지우는 SQL문 'CASCADE CONSTRAINTS'!!!
DROP TABLE DEPT10 CASCADE CONSTRAINTS;

DROP TABLE EMP10;

DROP TABLE EMP;


CREATE TABLE EMP (
    EMP_NO NUMBER CONSTRAINT EMP_NO_PK PRIMARY KEY,
    EMP_NAME VARCHAR2(100) NOT NULL,
    EMP_SALARY NUMBER(5,1)
);

SELECT *
FROM EMP;

SELECT EMP_NO 사원번호, EMP_NAME 사원이름, EMP_SALARY 월급
FROM EMP;


DROP TABLE STU;

CREATE TABLE STU(
     MNO NUMBER PRIMARY KEY,
     NAME VARCHAR2(100),
     EMAIL VARCHAR2(40)
);

--    시퀀스란?
--        오라클에서는 자동 증가 컬럼을 사용할 수가 없다. 다른 DB에서는 컬럼 자체에 옵션이 있으나
--        오라클에서 컬럼의 값을 증가시키기 위해서 MAX(컬럼)+1 또는 시퀀스 객체를 사용하여
--        일련번호와 같은 업무로직을 구현할 수 있다

--        일련번호?? 출석번호??

DROP SEQUENCE STU_MNO_SEQ;

--        시퀀스     시퀀스명
CREATE SEQUENCE STU_MNO_SEQ
INCREMENT BY 1
START WITH 1;

--NEXTVAL는 시퀀스의 값을 하나씩 증가하는 값을 리턴한다
SELECT STU_MNO_SEQ.NEXTVAL "번호가 1씩 증가"
FROM DUAL;

SELECT STU_MNO_SEQ.CURRVAL "시퀀스의 현재 번호"
FROM DUAL;

DESC STU;

INSERT INTO STU
(MNO, NAME, EMAIL)
VALUES(STU_MNO_SEQ.NEXTVAL, '학생1', 'stu1@ezen.com');

SELECT *
FROM STU;

INSERT INTO STU
(MNO, NAME, EMAIL)
VALUES(2, '학생2', 'stu1@ezen.com');

INSERT INTO STU
(MNO, NAME, EMAIL)
VALUES(3, '학생3', 'stu1@ezen.com');

INSERT INTO STU
(MNO, NAME, EMAIL)
VALUES(4, '학생4', 'stu1@ezen.com');

INSERT INTO STU
(MNO, NAME, EMAIL)
VALUES(5, '학생5', 'stu1@ezen.com');

--UPDATE TABLE명 SET 컬럼명 = ROWNUM
UPDATE STU SET MNO = ROWNUM;

--UPDATE 테이블 명 SET 컬럼명 =  NVL(MAX(컬럼명), 0)+ 1
--UPDATE STU SET MNO = NVL(MNO, MAX(MNO)+1, 1)+ 1;
